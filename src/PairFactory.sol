// SPDX-License-Identifier: MIT

pragma solidity ^0.8.26;

import {Ownable} from "../lib/openzeppelin-contracts/contracts/access/Ownable.sol";
import {IPairFactory} from "./interfaces/IPairFactory.sol";
import {Helper} from "./libraries/Helper.sol";
import {TokenPair} from "./TokenPair.sol";

contract PairFactory is IPairFactory, Ownable {
    error PairAlreadyExists();

    bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(TokenPair).creationCode));

    address public rewardTo;

    mapping(address => mapping(address => address)) public getPair;
    address[] public allPairs;

    constructor() Ownable(msg.sender) {
        rewardTo = msg.sender;
    }

    function allPairsLength() external view returns (uint256) {
        return allPairs.length;
    }

    function setRewardTo(address _rewardTo) external onlyOwner {
        rewardTo = _rewardTo;
    }

    function createPair(address tokenA, address tokenB) external returns (address pair) {
        // sort tokens in order to avoid duplicate pairs
        (address _tokenA, address _tokenB) = Helper.sortTokens(tokenA, tokenB);
        require(getPair[_tokenA][_tokenB] == address(0), PairAlreadyExists());

        // prepare create2 args
        // bytecode: Keccak256 hash of the creation code of TokenPair
        bytes memory bytecode = type(TokenPair).creationCode;
        // salt: keccak256 hash of concatenated sorted token address
        bytes32 salt = keccak256(abi.encodePacked(_tokenA, _tokenB));

        // deploy the token pair on the address
        // using factory address and salt
        // pair: pair address created by create2
        assembly {
            // 0: call value that is passed to create0
            // add(...): is the address of the initialization code of TokenPair contract
            //           the first 32bytes of data in creationCode of a contract
            //           is the length of initialization code
            // mload(...): returns the first 32 bytes of creationCode which is the length
            //             of the bytecode
            // salt: is generated by keccak256()
            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
            // the returned pair is the deploted TokenPair address
        }

        // initialize the token pair
        TokenPair(pair).initialize(_tokenA, _tokenB);

        // store the new token pair
        getPair[_tokenA][_tokenB] = pair;
        getPair[_tokenB][_tokenA] = pair;

        allPairs.push(pair);

        emit PairCreated(_tokenA, _tokenB, pair, allPairs.length);
    }
}

// keccak256() returns data of type bytes32 how ever the address is 160 bits
